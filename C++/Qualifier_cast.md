### 变量存储说明符与限定符(register,static,extern,auto,mutable  const,volatile)

1. *auto* 自动变量属于动态存储方式,只有在使用它,即定义该变量的函数被调用时,才给它分配存储单元,开始它的生命周期,函数调用结束,释放存储单元,结束生命周期,退出函数调用后自动变量的值不能保留.在复合语句中定义的自动变量,在退出复合语句后也不能在使用。
2. *register* 关键字用来声明局部变量.寄存器变量是放在CPU的寄存器中,不需要访问内存，能提供对变量的快速访问,但是分配空间与回收都取决与CPU.如果该变量被频繁使用,就请声明为register变量。
3. *static* 静态变量.未被初始化的静态变量一般都被设置成0,只能用常量表达式来初始化静态变量.可以使用const常量和enum常量以及sizeof操作符,static变量将被分一块独立的内存空间。用静态存储方式存储变量，生存周期为进程的整个执行时间。
类的静态成员函数只能访问类的静态成员。
不要在头文件中声明 static 变量和全局变量
4. *extern* 重新定义以前定义过的外部变量,该变量将自动隐藏定义过的外部变量.
按照默认规则，凡是在所有函数前，在函数外部定义的变量都是外部变量，定义时可以不写extern说明符，但是在一个函数体内使用在函数体外(在函数体定义之前没有定义的变量)或别的程序模块中定义过的变量时，必须使用extern说明符，一个外部变量被定义后，它就分配了固定的内存空间。
在一个程序里，一个对象只能定义一次，它可以有多个声明，但类型必须完全一样。如果定义在全局作用域或者名字空间作用域里某一个变量没有初始化，它会被按照默认方式初始化。
将变量或函数声明成外部链接，即该变量或函数名在其它函数中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。
5. *const* 表明程序对他进行初始化以后,便不能再被修改了.
6. *volatile* 即使程序代码没有对内存单元进行修改，其值也可能发生变化。一个对象可被外部进程（操作系统、硬件或并发进程等）改变。
7. *mutable* 即使结构或者类变量为const.其某个成员也可以被修改。

#### const、volatile

*const* 和 *volatile* 是类型修饰符，在C++中合称为cv-限定符(cv-qualifier)。可以共同使用，用于变量或函数参数声明，也可以限制非静态成员函数。
*const* 表示只读类型（指定类型安全性，保护对象不被意外修改），*volatile* 指定被修饰的对象类型的读操作是副作 用（因此读取不能被随便优化合并，适合映射I/O寄存器等）。

##### const与#define

*const* 定义常量是有数据类型的，而 *#define* 宏定义常量却没有。*const* 定义的常量编译器可以对其进行数据静态类型安全检查，而 *#define* 宏定义的常量却只是进行简单的字符替换，没有类型安全检查。当定义局部变量时，*const* 作用域仅限于定义局部变量的函数体内。但用 *#define* 时其作用域不仅限于定义局部变量的函数体内，而是从定义点到整个程序的结束点。但也可以用 *#undef* 取消其定义从而限定其作用域。

##### const使用

1. 修饰一般常量，常量数组，常量对象(修饰符 *const* 可以用在类型说明符前,也可以用在类型说明符后,但是必须初始化)。
2. 修饰指针、引用。
3. 修饰类的成员函数，任何不需修改数据成员的函数都应被指为 *const* 类型，可减少函数对数据成员的修改。
4. 修饰函数参数，返回类型，当修饰的是函数参数且传递是地址时，有保护实参的作用，修饰函数的返回值时返回值不可被改变。

#### 类型转换(const_cast,static_cast,dynamic_cast,reinterpret_cast)

##### 隐式转换

- 在混合类型表达式中，其操作数被转换为同一类型（向精度高的转换）
- 用作条件被转换为bool类型
- 用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量类型

##### 强制转换static_cast<type>(value)

- 用于类层次结构中基类和子类之间指针或引用的转换
　　进行上行转换（把子类的指针或引用转换成基类表示）是安全的
　　进行下行转换（把基类指针或引用转换成子类表示）时,由于没有动态类型检查,所以是不安全的
- 用于基本数据类型之间的转换.如把int转换成char,把int转换成enum.这种转换的安全性也要开发人员来保证
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转换成void类型

##### dynamic_cast< type * / & >(value)

- 用于类层次间进行转换
　　上行转换(由子类指针转换成父类指针),dynamic_cast 和 static_cast 的效果是一样的
　　下行转换(由父类指针转换成子类指针),dynamic_cast 具有类型检查的功能(通过虚函数表,所以子类必须有虚函数),比static_cast更安全
- dynamic_cast 还支持交叉转换（cross cast）,但是返回结果是 null
- dynamic_cast 基类转指正时候得到结果为 null
- type \*/&必须是类的指针或者引用

##### reinterpret_cast<type>(value)

- 可以把一个指针转换成一个整数,也可以把一个整数转换成一个指针（先把一个指针转换成一个整数,在把该整数转换成原类型的指针,还可以得到原先的指针值）。该运算符的用法比较多。
- 函数指针类型之间进行转换
- type-id必须是一个指针、引用、算术类型、函数指针或者成员指针
- 不能将非32bit的数据转成指针

##### c风格强制转换

　　（类型名）（表达式）
